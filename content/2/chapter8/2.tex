The LLVM core libraries optimize the IR your compiler creates and turn it into object code. This giant task is broken down into separate steps, called Passes. These Passes need to be executed in the right order, which is the objective of the Pass manager.\par

But why not hardcode the order of the Passes? Well, the user of your compiler usually expects that your compiler provides a different level of optimization. Developers prefer a faster compilation speed over-optimization during development time. The final application should run as fast as possible, and your compiler should be able to perform sophisticated optimizations, with longer compilation times accepted. A different level of optimization means a different number of optimization Passes that need to be executed. And, as a compiler writer, you might want to provide your own Passes to take advantage of your knowledge of the source language. For example, you might want to replace wellknown library functions with inline IR or, if possible, with the computed result of that function. For C, such a Pass is part of the LLVM core libraries, but for other languages, you will need to provide it yourself. And introducing your own Passes, you might need to reorder or add some Passes. For example, if you know that the operation of your Pass leaves some IR code unreachable, then you should also run the dead code removal Pass after your own Pass. The Pass manager helps you to organize these requirements.\par

A Pass is often categorized according to the scope in which it works:\par

\begin{itemize}
	\item A function Pass takes a single function as input and performs its work on this function only.
	\item A module Pass takes a whole module as input. Such a Pass performs its work on the 	given module and can be used for intraprocedural operations inside this module.
	\item A call graph Pass traverses the functions of a call graph in bottom-up order.
\end{itemize}

Besides the IR code, a Pass might also consume, produce, or invalidate some analysis results. There are a lot of different analyses performed; for example, alias analysis or the construction of a dominator tree. The dominator tree helps move invariant code out of a loop, so a Pass performing such a transformation can only run after the dominator tree has been created. Another Pass might perform a transformation that could invalidate the existing dominator tree.\par

Under the hood, the Pass manager ensures the following:\par

\begin{itemize}
	\item Analysis results are shared among Passes. This requires you to keep track of which Pass requires which analysis, and of the state of each analysis. The goal is to avoid needless recomputation of analyses and to free up the memory held by the analysis results as soon as possible.
	\item The Passes are executed in a pipeline fashion. For example, if several function Passes should be executed in sequence, then the Pass manager runs each of these function Passes on the first function. It will then run all function Passes on the second function, and so on. The underlying idea here is to improve the cache behavior, as the compiler performs transformations on only a limited set of data (that is, one IR function) and then moves on to the next limited set of data.
\end{itemize}

There are two Pass managers in LLVM, as follows: \par

\begin{itemize}
	\item The old (or legacy) Pass manager 
	\item The new Pass manager
\end{itemize}

The future belongs to the new Pass manager, but the transition is not yet complete. A number of crucial Passes, such as object code emission, have not yet been migrated to the new Pass manager, so it is important to understand both Pass managers.\par

The old Pass manager requires a Pass to inherit from a base class, for example, from the llvm::FunctionPass class for a function Pass. In contrast, the new Pass manager relies on a concept-based approach, requiring inheritance from the special llvm::PassInfo<> mixin class only. The dependence between Passes was not expressed explicitly with the old Pass manager. In the new Pass manager, it needs to be explicitly coded. The new Pass manager also features a different approach to handling analysis and allows the specification of an optimization pipeline through a textual representation on the command line. Some LLVM users reported a reduction of compile of up to 10\% just by switching from the old to the new Pass manager, which is a very convincing argument for using the new Pass manager.\par

First, we will implement a Pass for the new Pass manager and explore how to add it to the optimization pipeline. Later, we will take a look at how to use a Pass with the old Pass manager, too.\par

