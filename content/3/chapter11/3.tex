
To test your application, you'll need to write unit tests. This is a great way to make sure your software behaves correctly. However, due to the exponential number of possible inputs, you'll probably miss certain weird inputs, and a few bugs as well.\par

Fuzz testing can help here. The idea is to present your application with randomly generated data, or data based on valid input but with random changes. This is done over and over again, and so your application is tested with a large number of inputs. This is a very powerful testing approach. Literally hundreds of bugs in web browsers and other software have been found with fuzz testing.\par

LLVM comes with its own fuzz testing library. Originally part of the LLVM core libraries, the libFuzzer implementation was finally moved to compiler-rt. The library is designed to test small and fast functions.\par

Let's run a small example. You'll need to provide the LLVMFuzzerTestOneInput() function. This function is called by the fuzzer driver and provides you with some input. The following function counts consecutive ASCII digits in the input, and then we'll feed the random input to it. You'll need to save the example in the fuzzer.c file:\par

\begin{lstlisting}[caption={}]
#include <stdint.h>
#include <stdlib.h>

int count(const uint8_t *Data, size_t Size) {
	int cnt = 0;
	if (Size)
		while (Data[cnt] >= '0' && Data[cnt] <= '9') ++cnt;
	return cnt;
}

int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t
							Size) {
	count(Data, Size);
	return 0;
}
\end{lstlisting}

From the preceding code, the count() function counts the number of digits in the memory pointed to by the Data variable. The size of the data is only checked to determine whether there are any bytes available. Inside the while loop, the size is not checked.\par

Used with normal C strings, there will be no error because C strings are always terminated by a 0 byte. The LLVMFuzzerTestOneInput() function is the so-called fuzz target, and it is the function called by libFuzzer. It calls the function we want to test and returns 0, which is currently the only allowed value.\par

To compile the file with libFuzzer, you add the -fsanitize=fuzzer option. The recommendation is to also enable the address sanitizer and the generation of debug symbols. Use the following command to compile the file:\par

\begin{tcolorbox}[colback=white,colframe=black]
\$ clang -fsanitize=fuzzer,address -g fuzzer.c -o fuzzer
\end{tcolorbox}

When you run the test, a lengthy report is emitted. The report contains more information than a stack trace, so let's have a closer look at it:\par

\begin{enumerate}
\item The first line tells you the seed that was used to initialize the random number generator. You can use the –seed= option to repeat this execution:
\begin{tcolorbox}[colback=white,colframe=black]
INFO: Seed: 1297394926
\end{tcolorbox}

\item By default, libFuzzer limits inputs to at most 4,096 bytes. You can change the default by using the –max\underline{~}len= option:
\begin{tcolorbox}[colback=white,colframe=black]
INFO: -max\underline{~}len is not provided; libFuzzer will not \\
generate inputs larger than 4096 bytes
\end{tcolorbox}

\item Now, we run the test without providing sample input. The set of all sample inputs is called the corpus, and it is empty for this run:
\begin{tcolorbox}[colback=white,colframe=black]
INFO: A corpus is not provided, starting from an empty corpus
\end{tcolorbox}

\item Some information about the generated test data will follow. It shows you that 28 inputs were tried and 6 inputs, with a combined length of 19 bytes, were found, which together cover 6 coverage points or basic blocks:
\begin{tcolorbox}[colback=white,colframe=black]
\#28 NEW cov: 6 ft: 9 corp: 6/19b lim: 4 exec/s: 0 \\
rss: 29Mb L: 4/4 MS: 4 CopyPart-PersAutoDict-CopyPart- \\
ChangeByte- DE: "1$\setminus$x00"-
\end{tcolorbox}

\item After this, a buffer overflow was detected, and it follows the information from the address sanitizer. Lastly, the report tells you where the input causing the buffer overflow is saved:
\begin{tcolorbox}[colback=white,colframe=black]
artifact\underline{~}prefix='./'; Test unit written to ./crash-17ba0791499db908433b80f37c5fbc89b87\allowbreak 0084b
\end{tcolorbox}

\end{enumerate}

With the saved input, you can execute the test case with just the crashing input again:\par

\begin{tcolorbox}[colback=white,colframe=black]
\$ ./fuzzer crash-17ba0791499db908433b80f37c5fbc89b870084b
\end{tcolorbox}

This is obviously a great help to identify the problem. Only, using random data is often not very helpful. If you try to fuzz test the tinylang lexer or parser, then pure random data leads to immediate rejection of the input, because no valid token can be found. \par

In such cases, it is more useful to provide a small set of valid input, called the corpus. Then, the files of the corpus are randomly mutated and used as input. You can think of the input as mostly valid, with just a few bits flipped. This also works great with other input, which must have a certain format. For example, for a library processing JPEG and PNG files, you will provide some small JPEG and PNG files as the corpus.\par

You can save the corpus files in one or more directories and you can create a simple corpus for your fuzz test with the help of the printf command:\par

\begin{tcolorbox}[colback=white,colframe=black]
\$ mkdir corpus \\
\$ printf "012345$\setminus$0" >corpus/12345.txt \\
\$ printf "987$\setminus$0" >corpus/987.txt
\end{tcolorbox}

When running the test, you will provide the directory on the command line:\par

\begin{tcolorbox}[colback=white,colframe=black]
\$ ./fuzzer corpus/
\end{tcolorbox}

The corpus is then used as the base for generating random input, as the report tells you:\par

\begin{tcolorbox}[colback=white,colframe=black]
INFO: seed corpus: files: 2 min: 4b max: 7b total: 11b rss: 29Mb
\end{tcolorbox}

If you are testing a function that works on tokens or other magic values, such as a programming language, then you can speed up the process by providing a dictionary with the tokens. For a programming language, the dictionary would contain all the keywords and special symbols used in the language. The dictionary definitions follow a simple key-value style. For example, to define the if keyword in the dictionary, you can add the following:\par

\begin{tcolorbox}[colback=white,colframe=black]
kw1="if"
\end{tcolorbox}

However, the key is optional and can be left out. You can then specify the dictionary file on the command line with the –dict= option. In the next section, we'll get to know the limitations and alternatives for the libFuzzer implementation.\par

\hspace*{\fill} \par %插入空行
\textbf{Limitations and alternatives}

The libFuzzer implementation is fast but poses a number of restrictions on the test target. They are as follows:\par


\begin{itemize}
\item The function under test must accept the input as an array in memory. Some library functions require a file path to the data instead, and they cannot be tested with libFuzzer.

\item The exit() function should not be called.

\item The global state should not be altered.

\item Hardware random number generators should not be used.
\end{itemize}

From the aforementioned restrictions, the first two restrictions are an implication of the implementation of libFuzzer as a library. The latter two restrictions are needed to avoid confusion in the evaluation algorithm. If one of these restrictions is not met, then two identical calls to the fuzz target can give different results.\par

The best-known alternative tool for fuzz testing is AFL, found at \url{https://github.com/google/AFL}. AFL needs an instrumented binary (an LLVM plugin for instrumentation is provided) and requires the application to take the input as the file path on the command line. AFL and libFuzzer can share the same corpus and the same dictionary files. Thus, it is possible to test an application with both tools. In cases where libFuzzer is not applicable, AFL may be a good alternative.\par

There are many more ways of influencing the way libFuzzer works. You can read the reference page at \url{https://llvm.org/docs/LibFuzzer.html} for more details.\par

In the next section, we look at a totally different problem an application can have; we try to identify performance bottlenecks.\par















































