The definition of the instructions in the target description allows the construction of decoder tables, which are used to disassemble an object file into a textual assembler. The decoder tables and a decoder function are generated by the llvm-tblgen tool. Besides the generated code, we only need to provide the code to register and initialize the M88kDisassembler class and some helper functions to decode registers and operands.\par

We place the implementation in the Disassembler/M88kDisassembler.cpp file. The getInstruction() method of the M88kDisassembler class does the decoding work. It takes an array of bytes as input and decodes the next instruction into an instance of the MCInst class. The class declaration is as follows:\par

\begin{lstlisting}[caption={}]
using DecodeStatus = MCDisassembler::DecodeStatus;

namespace {
	
class M88kDisassembler : public MCDisassembler {
public:
	M88kDisassembler(const MCSubtargetInfo &STI, MCContext &Ctx)
		: MCDisassembler(STI, Ctx) {}
	~M88kDisassembler() override = default;
	
	DecodeStatus getInstruction(MCInst &instr, uint64_t &Size,
								ArrayRef<uint8_t> Bytes,
								uint64_t Address,
								raw_ostream &CStream) const
														override;
};
}
\end{lstlisting}

The generated classes refer unqualified to the DecodeStatus enumeration, so we have to make this name visible. \par

To initialize the disassembler, we define a factory function that simply instantiates a new object:\par

\begin{lstlisting}[caption={}]
static MCDisassembler *
createM88kDisassembler(const Target &T,
						const MCSubtargetInfo &STI,
						MCContext &Ctx) {
	return new M88kDisassembler(STI, Ctx);
}
\end{lstlisting}

In the LLVMInitializeM88kDisassembler() function, we register the factory function at the target registry:\par

\begin{lstlisting}[caption={}]
extern "C" LLVM_EXTERNAL_VISIBILITY void
LLVMInitializeM88kDisassembler() {
	TargetRegistry::RegisterMCDisassembler(
		getTheM88kTarget(), createM88kDisassembler);
}
\end{lstlisting}

This function is called from the InitializeAllDisassemblers() function or the InitializeNativeTargetDisassembler() function, when the LLVM core libraries are initialized.\par

The generated decoder function expects helper functions to decode registers and operands. The reason for this is that the encoding of those elements often involves special cases not expressed in the target description. For example, the distance between two instructions is always even, so the lowest bit can be ignored because it is always zero.\par

To decode the registers, the DecodeGPRRegisterClass() function has to be defined. The 32 registers are encoded with a number between 0 and 31, and we can use the static GPRDecoderTable table to map between the encoding and the generated enumeration for the registers:\par

\begin{lstlisting}[caption={}]
static const uint16_t GPRDecoderTable[] = {
	M88k::R0, M88k::R1, M88k::R2, M88k::R3,
	M88k::R4, M88k::R5, M88k::R6, M88k::R7,
	M88k::R8, M88k::R9, M88k::R10, M88k::R11,
	M88k::R12, M88k::R13, M88k::R14, M88k::R15,
	M88k::R16, M88k::R17, M88k::R18, M88k::R19,
	M88k::R20, M88k::R21, M88k::R22, M88k::R23,
	M88k::R24, M88k::R25, M88k::R26, M88k::R27,
	M88k::R28, M88k::R29, M88k::R30, M88k::R31,
};

static DecodeStatus
DecodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
						uint64_t Address,
						const void *Decoder) {
	if (RegNo > 31)
		return MCDisassembler::Fail;
		
	unsigned Register = GPRDecoderTable[RegNo];
	Inst.addOperand(MCOperand::createReg(Register));
	return MCDisassembler::Success;
}
\end{lstlisting}

All other required decoder functions follow the same pattern as the DecodeGPRRegisterClass() function:\par

\begin{enumerate}
\item Check that the value to decode fits the required size restriction. If not, then return the MCDisassembler::Fail value.

\item Decode the value and add it to the MCInst instance.

\item Return MCDisassembler::Success to indicate success.

\end{enumerate}

Then, we can include the generated decoder tables and function:\par

\begin{lstlisting}[caption={}]
#include "M88kGenDisassemblerTables.inc"
\end{lstlisting}

Finally, we are able to define the getInstruction() method. This method has two result values, the decoded instruction and the size of the instruction. If the byte array is too small, the size must be set to 0. This is important because the size parameter is used by the caller to advance the pointer to the next memory location, even if the decoding failed.\par

In the case of the M88k architecture, the method is simple, because all instructions are 4 bytes long. So, after extracting 4 bytes from the array, the generated decoder function can be called:\par

\begin{lstlisting}[caption={}]
DecodeStatus M88kDisassembler::getInstruction(
		MCInst &MI, uint64_t &Size, ArrayRef<uint8_t> Bytes,
		uint64_t Address, raw_ostream &CS) const {
	if (Bytes.size() < 4) {
		Size = 0;
		return MCDisassembler::Fail;
	}
	Size = 4;
	
	uint32_t Inst = 0;
	for (uint32_t I = 0; I < Size; ++I)
		Inst = (Inst << 8) | Bytes[I];
	return decodeInstruction(DecoderTableM88k32, MI, Inst,
							 Address, this, STI);
}
\end{lstlisting}

This finishes the implementation of the disassembler.\par

After we have implemented all the classes, we only need to set up the build system to pick up the new target backend, which we will add in the next section.\par





























