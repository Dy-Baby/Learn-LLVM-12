
A large portion of the DAG instruction selector is generated by the llvm-tblgen tool. We still need to create classes using the generated code and put everything together. Let's begin with a part of the initialization process.\par

\hspace*{\fill} \par %插入空行
\textbf{Initializing the target machine}

Each backend has to provide at least one TargetMachine class, usually a subclass of the LLVMTargetMachine class. The M88kTargetMachine class holds a lot of the details required for code generation, and it also acts as a factory for other backend classes, most notably for the Subtarget class and the TargetPassConfig class. The Subtarget class holds the configuration for the code generation, such as which features are enabled. The TargetPassConfig class configures the machine passes of the backend. The declaration for our M88kTargetMachine class is in the M88ktargetMachine.h file and looks like this:\par

\begin{lstlisting}[caption={}]
class M88kTargetMachine : public LLVMTargetMachine {
public:
	M88kTargetMachine(/* parameters */);
	~M88kTargetMachine() override;
	const M88kSubtarget *getSubtargetImpl(const Function &)
										  const override;
	const M88kSubtarget *getSubtargetImpl() const = delete;
	TargetPassConfig *createPassConfig(PassManagerBase &PM)
														override;
};
\end{lstlisting}

Please note that there can be a different subtarget for each function.\par

The implementation in the M88kTargetMachine.cpp file is straightforward. Most interesting is the setup of the machine passes for this backend. This creates the connection to the selection DAG (and, if desired, to global instruction selection). The passes created in the class are later added to the pass pipeline to produce object files or assemblers from the IR:\par

\begin{lstlisting}[caption={}]
namespace {
class M88kPassConfig : public TargetPassConfig {
public:
	M88kPassConfig(M88kTargetMachine &TM, PassManagerBase
		&PM)
			: TargetPassConfig(TM, PM) {}
		M88kTargetMachine &getM88kTargetMachine() const {
			return getTM<M88kTargetMachine>();
		}
	
		bool addInstSelector() override {
			addPass(createM88kISelDag(getM88kTargetMachine(),
			getOptLevel()));
			return false;
		}
	};
} // namespace

TargetPassConfig *M88kTargetMachine::createPassConfig(
		PassManagerBase &PM) {
	return new M88kPassConfig(*this, PM);
}
\end{lstlisting}

The SubTarget implementation return from the M88kTargetMachine class gives access to other important classes. The M88kInstrInfo class returns information about instructions, including registers. The M88kTargetLowering class provides a lowering of call-related instructions and also allows adding custom DAG rules. Most of the class is generated by the llvm-tblgen tool, and we need to include the generated header.\par

The definition in the M88kSubTarget.h file is as follows:\par

\begin{lstlisting}[caption={}]
#define GET_SUBTARGETINFO_HEADER
#include "M88kGenSubtargetInfo.inc"

namespace llvm {
class M88kSubtarget : public M88kGenSubtargetInfo {
	Triple TargetTriple;
	virtual void anchor();
	
	M88kInstrInfo InstrInfo;
	M88kTargetLowering TLInfo;
	M88kFrameLowering FrameLowering;
	
public:
	M88kSubtarget(const Triple &TT, const std::string &CPU,
				  const std::string &FS,
				  const TargetMachine &TM);
				  
	void ParseSubtargetFeatures(StringRef CPU, StringRef FS);
	
	const TargetFrameLowering *getFrameLowering() const
		override
	{ return &FrameLowering; }
	const M88kInstrInfo *getInstrInfo() const override
	{ return &InstrInfo; }
	const M88kRegisterInfo *getRegisterInfo() const override
	{ return &InstrInfo.getRegisterInfo(); }
	const M88kTargetLowering *getTargetLowering() const
		override
	{ return &TLInfo; }
};
} // end namespace llvm
\end{lstlisting}

Next, we implement the selection DAG.\par

\hspace*{\fill} \par %插入空行
\textbf{Adding the selection DAG implementation}

The selection DAG is implemented in the M88kDAGtoDAGIsel class in the file of the same name. Here, we benefit from having created the target machine description: most of the functionality is generated from this description. In a very first implementation, we only need to override the Select() function and forward it to the generated SelectCode function. More functions can be overridden for certain cases, for example, if we need to extend the preprocessing of the DAG or if we need to add special inline assembler constraints.\par

Because this class is a machine function pass, we also provide a name for the pass. The main bulk of the implementation comes from the generated file, which we include in the middle of the class:\par

\begin{lstlisting}[caption={}]
class M88kDAGToDAGISel : public SelectionDAGISel {
	const M88kSubtarget *Subtarget;
public:
	M88kDAGToDAGISel(M88kTargetMachine &TM,
			CodeGenOpt::Level OptLevel)
		: SelectionDAGISel(TM, OptLevel) {}
		
	StringRef getPassName() const override {
		return "M88k DAG->DAG Pattern Instruction Selection";
	}

#include "M88kGenDAGISel.inc"
	void Select(SDNode *Node) override {
		SelectCode(Node);
	}
};
\end{lstlisting}

We also add the factory function to create the pass in this file:\par

\begin{lstlisting}[caption={}]
FunctionPass *llvm::createM88kISelDag(M88kTargetMachine &TM,
									CodeGenOpt::Level
									OptLevel) {
	return new M88kDAGToDAGISel(TM, OptLevel);
}
\end{lstlisting}

Now we can implement the target-specific operations, which cannot be expressed in the target description.\par

\hspace*{\fill} \par %插入空行
\textbf{Supporting target-specific operations}

Let's turn to the M88kTargetLowering class, defined in the M88kISelLowering.h file. This class configures the instruction DAG selection process and enhances the lowering with target-specific operations.\par

In the target description, we defined new DAG nodes. The enumeration used with the new types is also defined in this file, continuing the numbering with the last predefined number:\par

\begin{lstlisting}[caption={}]
namespace M88kISD {
enum NodeType : unsigned {
	FIRST_NUMBER = ISD::BUILTIN_OP_END,
	RET_FLAG,
	SET,
};
} // end namespace M88kISD
\end{lstlisting}

The class needs to provide the required lowering methods for the function calls. To keep it simple, we look only at returning values. The class can also define the LowerOperation() hook method for operations that need custom handling. We can also enable custom DAG combining methods, for which we define the PerformDAGCombine() method:\par

\begin{lstlisting}[caption={}]
class M88kTargetLowering : public TargetLowering {
	const M88kSubtarget &Subtarget;
	
public:
	explicit M88kTargetLowering(const TargetMachine &TM,
								const M88kSubtarget &STI);
	
	SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const
														override;
	
	SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI)
													const override;
	
	SDValue LowerReturn(SDValue Chain, CallingConv::ID CallConv,
			bool IsVarArg,
			const SmallVectorImpl<ISD::OutputArg> &Outs,
			const SmallVectorImpl<SDValue> &OutVals,
			const SDLoc &DL,
			SelectionDAG &DAG) const override;
};
\end{lstlisting}

The implementation of the class is in the M88kISelLowering.cpp file. First, we look at how to lower a return value:\par

\begin{enumerate}
\item The generated functions for the calling convention are needed, so we include the generated file:
\begin{lstlisting}[caption={}]
#include "M88kGenCallingConv.inc"
\end{lstlisting}

\item The LowerReturn() method takes a lot of arguments, which are all defined by the TargetLowering superclass. The most important ones are the Outs vector, which holds the description of the return argument, and the OutVals vector, which holds the DAG nodes for the return values:
\begin{lstlisting}[caption={}]
SDValue M88kTargetLowering::LowerReturn(SDValue Chain,
	CallingConv::ID CallConv,
	bool IsVarArg,
	const SmallVectorImpl<ISD::OutputArg>
		&Outs,
	const SmallVectorImpl<SDValue> &OutVals,
	const SDLoc &DL, SelectionDAG &DAG) const {
\end{lstlisting}

\item We analyze the return argument with the help of the CCState class, passing a reference to the generated RetCC\underline{~}M88k function. As result, we have classified all the return arguments:
\begin{lstlisting}[caption={}]
	MachineFunction &MF = DAG.getMachineFunction();
	SmallVector<CCValAssign, 16> RetLocs;
	CCState RetCCInfo(CallConv, IsVarArg, MF, RetLocs,
										*DAG.getContext());
	RetCCInfo.AnalyzeReturn(Outs, RetCC_M88k);
\end{lstlisting}

\item In case of a void function, there is nothing to do and we return. Please note that the type of the returned node is RET\underline{~}FLAG. We defined this in the target description as the new ret\underline{~}flag node:
\begin{lstlisting}[caption={}]
	if (RetLocs.empty())
		return DAG.getNode(M88kISD::RET_FLAG, DL,
							MVT::Other, Chain);
\end{lstlisting}

\item Otherwise, we need to loop over the return arguments. For each return argument, we have an instance of the CCValAssign class, which tells us how we have to treat the argument:
\begin{lstlisting}[caption={}]
	SDValue Glue;
	SmallVector<SDValue, 4> RetOps;
	RetOps.push_back(Chain);
	for (unsigned I = 0, E = RetLocs.size(); I != E;
			++I) {
		CCValAssign &VA = RetLocs[I];
		SDValue RetValue = OutVals[I];
\end{lstlisting}

\item The values may need to be promoted. We add a DAG node with the required extension operation, if necessary:
\begin{lstlisting}[caption={}]
		switch (VA.getLocInfo()) {
			case CCValAssign::SExt:
				RetValue = DAG.getNode(ISD::SIGN_EXTEND, DL,
										VA.getLocVT(), RetValue);
				break;
			case CCValAssign::ZExt:
				RetValue = DAG.getNode(ISD::ZERO_EXTEND, DL,
										VA.getLocVT(), RetValue);
				break;
			case CCValAssign::AExt:
				RetValue = DAG.getNode(ISD::ANY_EXTEND, DL,
										VA.getLocVT(), RetValue);
				break;
			case CCValAssign::Full:
				break;
			default:
				llvm_unreachable("Unhandled VA.getLocInfo()");
		}
\end{lstlisting}

\item When the value has the right type, we copy the value into a register for returning it and chain and glue the copies together. This finishes the loop:
\begin{lstlisting}[caption={}]
		Register Reg = VA.getLocReg();
		Chain = DAG.getCopyToReg(Chain, DL, Reg, RetValue,
								Glue);
		Glue = Chain.getValue(1);
		RetOps.push_back(DAG.getRegister(Reg,
										VA.getLocVT()));
	}
\end{lstlisting}

\item Last, we need to update the chain and the glue:
\begin{lstlisting}[caption={}]
	RetOps[0] = Chain;
	if (Glue.getNode())
		RetOps.push_back(Glue);
\end{lstlisting}
	
\item We will then return the re\underline{~}flag node, connecting the result of the lowering:
\begin{lstlisting}[caption={}]
	return DAG.getNode(M88kISD::RET_FLAG, DL,
		MVT::Other,
						RetOps);
}
\end{lstlisting}
	
\end{enumerate}

To be able to call functions, we must implement the LowerFormalArguments() and LowerCall() methods. Both methods follow a similar approach and hence are not shown here.\par

\hspace*{\fill} \par %插入空行
\textbf{Configuring the target lowering}

The methods to lower function calls and arguments must always be implemented, as they are always target-dependent. Other operations may or may not have support in the target architecture. To make the lowering process aware of it, we set up the configuration in the constructor of the M88kTargetLowering class:\par

\begin{enumerate}
\item The constructor takes TargetMachine and M88kSubtarget instances as parameters and initializes the corresponding fields with them:
\begin{lstlisting}[caption={}]
M88kTargetLowering::M88kTargetLowering(
		const TargetMachine &TM, const M88kSubtarget &STI)
	: TargetLowering(TM), Subtarget(STI) {
\end{lstlisting}

\item We add all the register classes first. We have only general-purpose registers defined, therefore it is just a simple call:
\begin{lstlisting}[caption={}]
	addRegisterClass(MVT::i32, &M88k::GPRRegClass);
\end{lstlisting}

\item After all the register classes are added, we compute the derived properties for the registers. For example, since the registers are 32 bits wide, this function marks the 64-bit data type as requiring two registers:
\begin{lstlisting}[caption={}]
	computeRegisterProperties(Subtarget.getRegisterInfo());
\end{lstlisting}

\item We also need to tell which register is used for the stack pointer. On the M88k architecture, the r31 register is used:
\begin{lstlisting}[caption={}]
	setStackPointerRegisterToSaveRestore(M88k::R31);
\end{lstlisting}

\item We also need to define how boolean values are represented. Basically, we say here that the values 0 and 1 are used. Other possible options are to look only at bit 0 of the value, ignoring all other bits, and setting all bits of the value either to 0 or 1:
\begin{lstlisting}[caption={}]
	setBooleanContents(ZeroOrOneBooleanContent);
\end{lstlisting}

\item For every operation that needs special handling, we must call the setOperationAction() method. The method takes the operation, the value type, and the action to take as input. If the operation is valid, then we use the Legal action value. If the type should be promoted, then we use the Promote action value, and if the operation should result in a library call, then we use the LibCall action value.\par
If we give the Expand action value, then the instruction selection first tries to expand this operation into other operations. If this is not possible, then a library call is used. And last, we can implement our own action if using the Custom action value. In this case, the LowerOperation()method is called for a node with this operation. As an example, we set the CTTZ count trailing zeros operation to the Expand action. This operation will be replaced by a sequence of primitive bit operations:
\begin{lstlisting}[caption={}]
	setOperationAction(ISD::CTTZ, MVT::i32, Expand);
\end{lstlisting}

\item The M88k architecture has a bit field operation, for which it is not easy to define a pattern in the target description. Here, we tell the instruction selection that we want to perform additional matching on or DAG nodes:
\begin{lstlisting}[caption={}]
	setTargetDAGCombine(ISD::OR);
}
\end{lstlisting}

\end{enumerate}

Depending on the target architecture, setting the configuration in the constructor can be much longer. We only defined the bare minimum, ignoring, for example, floating-point operations.\par

We have marked the or operation to perform custom combining on it. As a result, the instruction selector calls the PerformDAGCombine() method before calling the generated instruction selection. This function is called in the various phases of the instruction selection, but usually, we perform our matching only after the operations are legalized. The common implementation is to look at the operation and branch to a function handling the matching:\par

\begin{lstlisting}[caption={}]
SDValue M88kTargetLowering::PerformDAGCombine(SDNode *N,
DAGCombinerInfo &DCI) const {
	if (DCI.isBeforeLegalizeOps())
		return SDValue();
	switch (N->getOpcode()) {
		default:
			break;
		case ISD::OR:
			return performORCombine(N, DCI);
	}
	return SDValue();
}
\end{lstlisting}

In the performORCombine() method, we try to check whether we can generate a set instruction for the or operation. The set instruction sets a number of consecutive bits to 1, starting at a specified bit offset. This is a special case of the or operation, with the second operand being a constant matching this format. Because the or instruction of the M88k architecture works only on 16-bit constants, this matching is beneficial, because otherwise, we would have to synthesize the constant, resulting in two or instructions. This method uses the isShiftedMask() helper function to determine whether the constant values have the required form.\par

If the second operand is a constant of the required form, then this  function returns a node representing the set instruction. Otherwise, the return value  SDValue() indicates that no matching pattern was found and that the generated DAG pattern matcher should be called:\par

\begin{lstlisting}[caption={}]
SDValue performORCombine(SDNode *N,
		TargetLowering::DAGCombinerInfo &DCI) {
	SelectionDAG &DAG = DCI.DAG;
	uint64_t Width, Offset;
	ConstantSDNode *Mask =
					dyn_cast<ConstantSDNode>(N->getOperand(
						1));
	if (!Mask ||
		!isShiftedMask(Mask->getZExtValue(), Width, Offset))
		return SDValue();
	
	EVT ValTy = N->getValueType(0);
	SDLoc DL(N);
	return DAG.getNode(M88kISD::SET, DL, ValTy,
			N->getOperand(0),
			DAG.getConstant(Width << 5 | Offset, DL,
				MVT::i32));
}
\end{lstlisting}

To finish the implementation of the whole lowering process, we need to implement the M88kFrameLowering class. This class is responsible for handling the stack frame. This includes generating the prologue and epilogue code, handling register spills, and more.\par

For the very first implementation, you can just provide empty functions. Obviously, for complete functionality, this class must be implemented. This finishes our implementation of the instruction selection. Next, we look at how the final instructions are emitted.\par





























