
The future belongs to the new Pass manager, and it makes no sense to develop a new Pass for the old Pass manager exclusively. However, during the ongoing transition phase, it would be useful if a Pass could work with both Pass managers, as most of the Passes in LLVM already do.\par

The old Pass manager requires a Pass that has been derived from certain base classes. For example, a function Pass must derive from the FunctionPass base class. There are more differences, too. The method run by the Pass manager is named runOnFunction(), and an ID for the Pass must also be provided. The strategy we follow here is to create a separate class that we can use with the old Pass manager and refactor the source code in a way that the functionality can be used with both Pass managers.\par

We use the Pass plugin as a base. In the include/CountIR.h header file, we add a new class definition, as follows:\par

\begin{enumerate}
	\item The new class needs to derive from the FunctionPass class, so we include an additional header to get the class definition:
	\begin{lstlisting}[caption={}]
		#include "llvm/Pass.h"
	\end{lstlisting}
	
	\item We name the new class CountIRLegacyPass. The class needs an ID for the internal LLVM machinery, and we initialize the parent class with it:
	\begin{lstlisting}[caption={}]
		class CountIRLegacyPass : public llvm::FunctionPass {
			public:
			static char ID;
			CountIRLegacyPass() : llvm::FunctionPass(ID) {}
		\end{lstlisting}
		
		\item In order to implement the Pass functionality, two functions must be overridden. The runOnFunction() method is called for every LLVM IR function and implements our counting functionality. The getAnalysisUsage() method is used to announce that all of the analysis results are saved:
		\begin{lstlisting}[caption={}]
			bool runOnFunction(llvm::Function &F) override;
			void getAnalysisUsage(llvm::AnalysisUsage &AU) const 
			override;
		};
	\end{lstlisting}
	
	\item With the changes to the header file now complete, we can enhance the implementation inside the lib/CountIR.cpp file. To reuse the counting functionality, we move the source code into a new function:
	\begin{lstlisting}[caption={}]
		void runCounting(Function &F) {
			for (BasicBlock &BB : F) {
				++NumOfBB;
				for (Instruction &I : BB) {
					(void)I;
					++NumOfInst;
				}
			}
		}
	\end{lstlisting}
	
	\item The method for the new Pass manager needs to be updated in order to use the 
	new function:
	\begin{lstlisting}[caption={}]
		PreservedAnalyses
		CountIRPass::run(Function &F, FunctionAnalysisManager 
		&AM) {
			runCounting(F);
			return PreservedAnalyses::all();
		}
	\end{lstlisting}
	
	\item In the same way, we implement the method for the old Pass manager. With the false return value, we indicate that the IR did not change:
	\begin{lstlisting}[caption={}]
		bool CountIRLegacyPass::runOnFunction(Function &F) {
			runCounting(F);
			return false;
		}
	\end{lstlisting}
	
	\item To preserve the existing analysis results, the getAnalysisUsage() method must be implemented in the following way. This is similar to the PreservedAnalyses::all() return value in the new Pass manager. If you do not implement this method, then all analysis results are thrown away by default:
	\begin{lstlisting}[caption={}]
		void CountIRLegacyPass::getAnalysisUsage(
		AnalysisUsage &AU) const {
			AU.setPreservesAll();
		}
	\end{lstlisting}
	
	\item The ID field can be initialized with an arbitrary value because LLVM uses the address of the field. The common value is 0, so we use it too:
	\begin{lstlisting}[caption={}]
		char CountIRLegacyPass::ID = 0;
	\end{lstlisting}
	
	\item Only the Pass registration is missing now. To register the new Pass, we need to provide a static instance of the RegisterPass<> template. The first argument is the name of the command-line option to invoke the new Pass. The second argument is the name of the Pass, which is used, among other things, as information for the user when invoking the -help option:
	\begin{lstlisting}[caption={}]
		static RegisterPass<CountIRLegacyPass>
		X("countir", "CountIR Pass");
	\end{lstlisting}
	
	\item These changes are enough to allow us to invoke our new Pass under the old Pass manager and the new Pass manager. To test the addition, change back into the build folder and compile the Pass:
	\begin{tcolorbox}[colback=white,colframe=black]
		\$ ninja
	\end{tcolorbox}
	
	\item To load the plugin for use with the old Pass manager, we need to use the \verb|--|load option. Our new Pass is invoked with the \verb|--|countir option:
	\begin{tcolorbox}[colback=white,colframe=black]
		\$ opt \verb|--|load-pass-plugin=lib/CountIR.so \verb|--|countir \verb|â€“-|stats$\setminus$ \\
		\hspace*{0.5cm}\verb|--|disable-output demo.ll
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, title=Tip]
		Please also check, in the command line from the previous section, that the invocation of our Pass with the new Pass manager still works fine!
	\end{tcolorbox}
	
\end{enumerate}

Being able to run our new Pass with an LLVM-provided tool is nice, but ultimately, we want to run it inside our compiler. In the next section, we will explore how to set up an optimization pipeline and how to customize it.\par






